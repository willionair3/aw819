<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <title>awSince1984</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #111;
        }

        canvas {
            display: block;
            margin: auto;
            background: #111;
            touch-action: none;
        }

        #startOverlay {
            position: fixed;
            /* cover entire viewport */
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            /* center the button */
            justify-content: center;
            align-items: center;
            z-index: 1000;
            /* on top of everything */
        }

        #startButton {
            padding: 20px 50px;
            font-size: 24px;
            cursor: pointer;
            background-color: #28a745;
            border: none;
            border-radius: 8px;
            color: white;
            transition: background-color 0.3s ease;
        }

        #startButton:hover {
            background-color: #218838;
        }

        #swipeOverlay {
            position: fixed;
            top: 60px;
            /* adjust this to position near top */
            left: 50%;
            transform: translateX(-50%);
            background: transparent;
            /* no background */
            padding: 0;
            color: white;
            text-align: center;
            z-index: 1100;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            max-width: 300px;
            pointer-events: none;
            font-size: 18px;
            /* bigger text */
            font-weight: bold;
            user-select: none;
        }

        .auto-scroll-button {
            padding: 16px 24px;
            /* larger padding */
            font-size: 20px;
            /* bigger text */
            min-width: 100px;
            /* wider button */
            min-height: 48px;
            /* tall enough */
            border-radius: 12px;
            cursor: pointer;
            background-color: #007bff;
            color: white;
            border: none;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        /* Optional: further increase for very small screens */
        @media (max-width: 360px) {
            .auto-scroll-button {
                padding: 20px 28px;
                font-size: 22px;
                min-width: 120px;
                min-height: 54px;
            }
        }
    </style>
</head>

<body>

    <canvas id="gameCanvas"></canvas>

    <div id="swipeOverlay" style="
    position: fixed;
    top: 60px;
    left: 50%;
    transform: translateX(-50%);
    color: white;
    font-family: monospace, monospace;
    font-size: 36px;
    font-weight: bold;
    text-align: center;
    pointer-events: none;
    z-index: 1100;">
        <div>Swipe and hold left or right to move</div>
    </div>


    <div id="startOverlay">
        <button id="startButton">Start</button>
    </div>

    <button id="autoScrollBtn" class="auto-scroll-button"
        style="position: fixed; bottom: 20px; right: 20px; z-index: 100;">
        Start Auto-Scroll
    </button>

    <!-- GameAnalytics SDK -->
    <script>
        (function (w, d, s, u) {
            w['GameAnalytics'] = w['GameAnalytics'] || function () {
                (w['GameAnalytics'].q = w['GameAnalytics'].q || []).push(arguments)
            };
            var ga = d.createElement(s), m = d.getElementsByTagName(s)[0];
            ga.async = 1;
            ga.src = u;
            m.parentNode.insertBefore(ga, m);

            // Initialize after SDK loaded
            ga.onload = function () {
                GameAnalytics("setEnabledInfoLog", true);
                GameAnalytics("initialize", "74d3259c304d64ec6ad15574eb975019", "d9212b3ec2f73ae0648888f637774c1b8b455bcf");
                console.log("GameAnalytics initialized");
            };

            // Fallback if onload doesn't fire reliably
            ga.onreadystatechange = function () {
                if (this.readyState === 'complete') {
                    GameAnalytics("setEnabledInfoLog", true);
                    GameAnalytics("initialize", "74d3259c304d64ec6ad15574eb975019", "d9212b3ec2f73ae0648888f637774c1b8b455bcf");
                    console.log("GameAnalytics initialized (onreadystatechange)");
                }
            };

        })(window, document, 'script', 'https://download.gameanalytics.com/js/GameAnalytics-2.1.2.min.js');
    </script>


    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const isMobile = window.innerWidth <= 600;

        let autoScrolling = false;
        const autoScrollSpeed = isMobile ? 256 : 3; // Pixels to scroll per game loop frame (adjust as needed)

        // Frame dimensions and scale
        const frameWidth = 40;
        const frameHeight = 60;
        let canvasWidth, canvasHeight;
        let scale;
        let scaledWidth, scaledHeight;

        function scaledValue(val) {
            return Math.floor(val * scale);
        }

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            canvasWidth = canvas.width;
            canvasHeight = canvas.height;

            scale = Math.floor(canvasHeight / 100) || 2;
            if (scale < 2) scale = 2;

            scaledWidth = frameWidth * scale;
            scaledHeight = frameHeight * scale;
        }
        // Immediately call once:
        resizeCanvas();
        // Update on window resize:
        window.addEventListener('resize', resizeCanvas);
        // === Add near the top with your other globals ===

        const uiScale = Math.min(scale, 4); // cap max scale for UI elements

        function scaledUIButtonValue(val) {
            return Math.floor(val * uiScale);
        }

        // Determine button sizes
        let buttonWidth = scaledUIButtonValue(70);
        const buttonHeight = scaledUIButtonValue(35);
        const buttonGap = scaledUIButtonValue(15);

        const padding = scaledUIButtonValue(10); // 10 base pixels scaled

        // Calculate button X positions centered horizontally with some gap
        const yesButtonX = canvasWidth / 2 - buttonWidth - buttonGap / 2;
        const noButtonX = canvasWidth / 2 + buttonGap / 2;

        // Ensure yesButtonX >= 0 to avoid left half cut off:
        const clampedYesButtonX = Math.max(yesButtonX, padding);

        // Ensure buttons don’t overflow right edge:
        const maxNoButtonX = canvasWidth - buttonWidth - scaledUIButtonValue(10);
        const clampedNoButtonX = Math.min(noButtonX, canvasWidth - buttonWidth - padding);

        // Y position relative to bottom of canvas
        const buttonsY = canvasHeight - buttonHeight - scaledUIButtonValue(20);

        const totalButtonWidth = buttonWidth * 2 + buttonGap;
        const availableWidth = canvasWidth - scaledUIButtonValue(20); // Left + right padding total

        const charSpacing = scaledWidth * 0.75; // 75% width to overlap or get closer

        const firstCharX = 100; // starting x position
        const secondCharX = firstCharX + charSpacing;

        if (totalButtonWidth > availableWidth) {
            // reduce buttonWidth, or buttonGap dynamically here
            buttonWidth = (availableWidth - buttonGap) / 2;
        }

        // === Add these variables for choice screen fade and typing effect ===
        let fadeAlpha = 0;
        const fadeIncrement = 0.02;
        let choiceSentenceIndex = 0;
        let charIndex = 0;
        let charTimer = 0;
        const charDelay = isMobile ? 2 : 5; // Faster typing on phones;
        const sentencePause = 200;
        let pauseJustStarted = false;
        let pauseTimer = 0;

        const choiceSentences = [
            "What makes you different this time?",
            "Because I don't know starting from exactly when",
            "You have literally become a part of my heart..",
            "People always say home is where your heart belongs",
            "Now I finally realized you are my home.",
            "The one calming factor amongst all chaos.",
            "No matter how bad it is, as soon as I hear from you,",
            "Everything just clears up.",
            "But I was blinded, I let my selfishness get the better of me.",
            "And didn't realize you have always been the one I fell madly in love with.",
            "Now everything is too late...but I will wait.",
            "How can you wait for someone who might never come back?",
            "Because you are where my heart belongs.",
            "而我...只想把餘生的溫柔都給你",
            "What if I really don't?",
            "Then I will be a broken heart that finally, finally loved you fully.",
            "I don't expect you to promise me anything - not a timeframe, not even certainty.",
            "I'll wait because I'd rather spend my life hoping for you than living without you.",
            "And even if you never come back, I will still be glad I waited.",
            "Because you have always been the one, and you will always be the one.",
            "And if there really are parallel universes, I know I will be loving you in every single one of them.",
            "Because you are the reason I am, you're all my reasons, I just didn't even know myself."
        ];

        const choiceBg = new Image();
        choiceBg.src = 'background_hk.png';  // Your choice screen background image

        // Animation frame arrays
        const boyIdleFrames = ['pixel_boy_idle_1.png', 'pixel_boy_idle_2.png', 'pixel_boy_idle_3.png'];
        const boyWalkFrames = ['pixel_boy_walk_1.png', 'pixel_boy_walk_2.png', 'pixel_boy_walk_3.png', 'pixel_boy_walk_4.png'];
        const boyCryingFrames = ['pixel_boy_crying_1.png', 'pixel_boy_crying_2.png', 'pixel_boy_crying_3.png'];
        const boyCryingWalkFrames = ['pixel_boy_crying_walk_1.png', 'pixel_boy_crying_walk_2.png', 'pixel_boy_crying_walk_3.png', 'pixel_boy_crying_walk_4.png'];

        const soulmateIdleFrames = ['pixel_soulmate_idle_1.png', 'pixel_soulmate_idle_2.png', 'pixel_soulmate_idle_3.png'];
        const soulmateWalkFrames = ['pixel_soulmate_walk_1.png', 'pixel_soulmate_walk_2.png', 'pixel_soulmate_walk_3.png', 'pixel_soulmate_walk_4.png'];

        const boyMaskedFrames = ['pixel_boy_masked_1.png', 'pixel_boy_masked_2.png', 'pixel_boy_masked_3.png'];
        const soulmateMaskedFrames = ['pixel_soulmate_masked_1.png', 'pixel_soulmate_masked_2.png', 'pixel_soulmate_masked_3.png'];

        const boyMaskedWalkFrames = ['pixel_boy_masked_walk_1.png', 'pixel_boy_masked_walk_2.png', 'pixel_boy_masked_walk_3.png', 'pixel_boy_masked_walk_4.png'];
        const soulmateMaskedWalkFrames = ['pixel_soulmate_masked_walk_1.png', 'pixel_soulmate_masked_walk_2.png', 'pixel_soulmate_masked_walk_3.png', 'pixel_soulmate_masked_walk_4.png'];

        const boyMaskedCryingFrames = ['pixel_boy_masked_crying_1.png', 'pixel_boy_masked_crying_2.png', 'pixel_boy_masked_crying_3.png', 'pixel_boy_masked_crying_4.png'];

        const afterChoiceYesFrames = [
            { backgroundColor: '#f5f0e6', text: "Budapest: A new journey begins.", bgImageSrc: 'pixel_budapest.png' },
            { backgroundColor: '#d0d7de', text: "Prague: Exploring ancient streets.", bgImageSrc: 'pixel_prague.png' },
            { backgroundColor: '#f0e68c', text: "India: A land of colors and wonders.", bgImageSrc: 'pixel_india.png' },
            { backgroundColor: '#f0e68c', text: "Mexico: The land of tacos.", bgImageSrc: 'pixel_mexico.png' },
            { backgroundColor: '#add8e6', text: "Norway: LIGHTS.", bgImageSrc: 'pixel_norway.png' },
            { backgroundColor: '#add8e6', text: "North Pole: Embracing new horizons.", bgImageSrc: 'pixel_northpole.png' },
            { backgroundColor: '#add8e6', text: "Berlin: Reminiscing moments.", bgImageSrc: 'pixel_berlin.png' },
            { backgroundColor: '#add8e6', text: "Taipei: Heartfelt memories.", bgImageSrc: 'pixel_taipei.png' },
            { backgroundColor: '#add8e6', text: "Paris: Timeless love.", bgImageSrc: 'pixel_paris_2.png' },
            { backgroundColor: '#add8e6', text: "New York: City that never sleeps.", bgImageSrc: 'pixel_newyork.png' },
            { backgroundColor: '#add8e6', text: "China: Exploring the mysteries.", bgImageSrc: 'pixel_china.png' },
            { backgroundColor: '#add8e6', text: "Hong Kong: Home forever.", bgImageSrc: 'background_hk.png' },
            { backgroundColor: '#add8e6', text: "Vow renewed, Infinite adventures around the globe.", bgImageSrc: 'pixel_earth.png' }
        ];

        const storyMilestones = [
            { x: 0, year: 2011, text: "The boy started the year filled with hope.", soulmateVisible: true, bg: 'sf' },
            { x: isMobile ? 60 : 150, year: 2011, text: "In August, they started dating officially.", soulmateVisible: true, bg: 'hk' },
            { x: isMobile ? 120 : 300, year: 2011, text: "Long Distance...", soulmateVisible: false, bg: 'sf' },
            { x: isMobile ? 180 : 450, year: 2011, text: "Reunited by Xmas.", soulmateVisible: true, bg: 'hk' },
            { x: isMobile ? 240 : 600, year: 2012, text: "Love deepens over time.", soulmateVisible: true, bg: 'hk' },
            { x: isMobile ? 300 : 900, year: 2012, text: "First trip ever with a significant other.", soulmateVisible: true, bg: 'tokyo' },
            { x: isMobile ? 400 : 1200, year: 2013, text: "She said YES!!", soulmateVisible: true, bg: 'paris' },
            { x: isMobile ? 500 : 1500, year: 2014, text: "Preparing for a joyful moment, but she did all the works..", soulmateVisible: true, bg: 'hk' },
            { x: isMobile ? 600 : 1800, year: 2014, text: "Wedding photoshoot in Verona.", soulmateVisible: true, bg: 'verona' },
            { x: isMobile ? 700 : 2100, year: 2015, text: "Wedding day surrounded by love.", soulmateVisible: true, bg: 'hk' },
            { x: isMobile ? 800 : 2400, year: 2015, text: "Moved in together, but I took up all the spaces.", soulmateVisible: true, bg: 'hk' },
            { x: isMobile ? 900 : 2700, year: 2015, text: "Honeymoon in Positano.", soulmateVisible: true, bg: 'postiano' },
            { x: isMobile ? 1000 : 3000, year: 2016, text: "No matter how selfish I am, she's still here.", soulmateVisible: true, bg: 'hk' },
            { x: isMobile ? 1100 : 3300, year: 2017, text: "Cherished moments together.", soulmateVisible: true, bg: 'hk' },
            { x: isMobile ? 1200 : 3600, year: 2018, text: "How I wish I could turn back time.", soulmateVisible: true, bg: 'hk' },
            { x: isMobile ? 1300 : 3900, year: 2019, text: "Still loving me no matter how selfish i am..", soulmateVisible: true, bg: 'hk' },
            { x: isMobile ? 1400 : 4200, year: 2020, text: "A world changed, faces masked.", soulmateVisible: true, bg: 'hk', maskedVisible: true },
            { x: isMobile ? 1500 : 4500, year: 2020, text: "Tough time in September...", soulmateVisible: false, bg: 'hk', maskedVisible: true },
            { x: isMobile ? 1600 : 4800, year: 2020, text: "She came back, but I soon forgot about my promises...", soulmateVisible: true, bg: 'hk', maskedVisible: true },
            { x: isMobile ? 1700 : 5100, year: 2021, text: "Yet she is still trying to make us better..", soulmateVisible: true, bg: 'hk', maskedVisible: true },
            { x: isMobile ? 1800 : 5400, year: 2022, text: "New beginnings in a new home.", soulmateVisible: true, bg: 'hk', maskedVisible: true },
            { x: isMobile ? 1900 : 5700, year: 2023, text: "First trip since the pandemic.", soulmateVisible: true, bg: 'tokyo' },
            { x: isMobile ? 2000 : 6000, year: 2024, text: "Celebrated our big birthdays together.", soulmateVisible: true, bg: 'hk' },
            { x: isMobile ? 2100 : 6300, year: 2025, text: "10 years wedding anniversary.", soulmateVisible: true, bg: 'hk' },
            { x: isMobile ? 2300 : 6600, year: 2025, text: "Uncertainty looms..Marriage at crossroads..", soulmateVisible: false, bg: 'hk' },
        ];

        const GamePhase = { Story: 0, Choice: 1, AfterChoiceYes: 2, AfterChoiceNo: 3, End: 4 };
        let gamePhase = GamePhase.Story;
        let playerChoice = null;
        let afterChoiceYesIndex = 0;
        let worldOffsetX = 0;

        // New scroll offset for afterChoiceYes frames
        let afterChoiceWorldOffsetX = 0;

        const characterScale = 0.5; // Scale down to half size (16x16)

        // Calculate scaled width and height
        const scaledCharacterWidth = 32 * characterScale;
        const scaledCharacterHeight = 32 * characterScale;
        const paddingBottom = scaledValue(40) || 40;

        const scrollSpeed = isMobile ? 15 : 9;
        const boyScreenX = scaledValue(20);
        const xGap = scaledValue(8);
        const soulmateScreenX = boyScreenX + scaledCharacterWidth + xGap;
        const charScreenY = canvasHeight - scaledCharacterHeight - paddingBottom;

        let animationFrame = 0;
        let animationTimer = 0;
        let previousFrames = null;

        let movingLeft = false;
        let movingRight = false;

        // Load backgrounds
        const bg_sf = new Image(); bg_sf.src = 'pixel_sf.png';
        const bg_hk = new Image(); bg_hk.src = 'pixel_hk.png';
        const bg_paris = new Image(); bg_paris.src = 'pixel_paris.png';
        const bg_postiano = new Image(); bg_postiano.src = 'pixel_postiano.png';
        const bg_tokyo = new Image(); bg_tokyo.src = 'pixel_tokyo.png';
        const bg_verona = new Image(); bg_verona.src = 'pixel_verona.png';

        // After choice YES backgrounds
        const afterChoiceYesBgImgs = afterChoiceYesFrames.map(frame => {
            const img = new Image();
            img.src = frame.bgImageSrc;
            return img;
        });

        function preloadFrames(urls) {
            return urls.map(url => {
                const img = new Image();
                img.src = url;
                return img;
            });
        }

        // Load sprite frames
        const boyIdleImgs = preloadFrames(boyIdleFrames);
        const boyWalkImgs = preloadFrames(boyWalkFrames);
        const boyCryingImgs = preloadFrames(boyCryingFrames);
        const boyCryingWalkImgs = preloadFrames(boyCryingWalkFrames);
        const soulmateIdleImgs = preloadFrames(soulmateIdleFrames);
        const soulmateWalkImgs = preloadFrames(soulmateWalkFrames);
        const boyMaskedImgs = preloadFrames(boyMaskedFrames);
        const soulmateMaskedImgs = preloadFrames(soulmateMaskedFrames);
        const boyMaskedWalkImgs = preloadFrames(boyMaskedWalkFrames);
        const soulmateMaskedWalkImgs = preloadFrames(soulmateMaskedWalkFrames);
        const boyMaskedCryingImgs = preloadFrames(boyMaskedCryingFrames);

        // Asset loading tracker
        const assets = [
            bg_sf, bg_hk, bg_paris, bg_postiano, bg_tokyo, bg_verona,
            ...boyIdleImgs, ...boyWalkImgs, ...boyCryingImgs, ...boyCryingWalkImgs,
            ...soulmateIdleImgs, ...soulmateWalkImgs,
            ...boyMaskedImgs, ...soulmateMaskedImgs,
            ...boyMaskedWalkImgs, ...soulmateMaskedWalkImgs, ...boyMaskedCryingImgs,
            ...afterChoiceYesBgImgs
        ];

        let assetsLoaded = 0;
        assets.forEach(img => img.onload = () => {
            assetsLoaded++;
            if (assetsLoaded === assets.length) {
                console.log("All assets loaded, starting game.");
                requestAnimationFrame(gameLoop);
            }
        });

        // Calculate the positive offset for milestone checking
        function getCurrentMilestone() {
            const positiveOffset = -worldOffsetX;
            for (let i = storyMilestones.length - 1; i >= 0; i--) {
                // Multiply milestone x by scale for dynamic world size
                if (positiveOffset >= storyMilestones[i].x * scale) return i;
            }
            return 0;
        }

        function getCurrentMilestoneIndex() {
            const positiveOffset = -worldOffsetX;
            for (let i = storyMilestones.length - 1; i >= 0; i--) {
                if (positiveOffset >= storyMilestones[i].x * scale) return i;
            }
            return 0;
        }

        function drawYearOnTopRight(year) {
            ctx.font = `${Math.floor(canvasHeight * 0.035)}px monospace`;
            ctx.fillStyle = 'white';
            ctx.textAlign = 'right';
            ctx.textBaseline = 'top';

            const x = canvasWidth - scaledValue(10);
            const y = scaledValue(10);

            ctx.fillText(year.toString(), x, y);
        }

        function currentBgImage() {
            const idx = getCurrentMilestone();
            const bgImg = storyMilestones[idx].bg;

            switch (bgImg) {
                case 'sf':
                    return bg_sf
                case 'tokyo':
                    return bg_tokyo
                case 'verona':
                    return bg_verona
                case 'paris':
                    return bg_paris
                case 'postiano':
                    return bg_postiano
                default:
                    return bg_hk
            }
        }

        function currentSoulmateVisible() {
            if (gamePhase === GamePhase.Choice || gamePhase === GamePhase.AfterChoiceNo) return false;
            if (gamePhase === GamePhase.AfterChoiceYes) return true;
            return storyMilestones[getCurrentMilestone()].soulmateVisible;
        }

        function currentSoulmateMaskedVisible() {
            return storyMilestones[getCurrentMilestone()].maskedVisible || false;
        }

        function currentStoryText() {
            if (gamePhase === GamePhase.AfterChoiceYes) {
                return afterChoiceYesFrames[afterChoiceYesIndex].text;
            }
            return storyMilestones[getCurrentMilestone()].year + ' ' + storyMilestones[getCurrentMilestone()].text
        }

        // Animation update with frame array tracking and reset on change
        let currentFrames = boyIdleImgs; // default animation frames

        // Define animation states
        const AnimationState = {
            IDLE: 'idle',
            WALK: 'walk',
            MASKED: 'masked',
            MASKED_CRYING: 'maskedCrying',
            CRYING: 'crying',
            AFTER_CHOICE_YES: 'afterChoiceYes'
        };

        // Add a variable to keep track of current animation state
        let currentAnimationState = AnimationState.IDLE;

        function determineAnimationState() {
            // Get current milestone based on playerX
            const currentMilestone = storyMilestones[getCurrentMilestone()];
            const isMasked = currentMilestone.maskedVisible === true;
            const soulmateVisibleFlag = currentMilestone.soulmateVisible !== false; // default true if missing

            if (gamePhase === GamePhase.AfterChoiceYes) {
                return AnimationState.AFTER_CHOICE_YES;
            }

            if (movingLeft || movingRight || autoScrolling) {
                if (isMasked && !soulmateVisibleFlag) return AnimationState.MASKED_CRYING;
                if (isMasked) return AnimationState.MASKED;
                if (!soulmateVisibleFlag) return AnimationState.CRYING;
                return AnimationState.WALK;
            } else {
                if (isMasked && !soulmateVisibleFlag) return AnimationState.MASKED_CRYING;
                if (isMasked) return AnimationState.MASKED;
                if (!soulmateVisibleFlag) return AnimationState.CRYING;
                return AnimationState.IDLE;
            }
        }

        function updateAnimation() {
            animationTimer++;
            const animationRate = (movingLeft || movingRight || autoScrolling) ? 6 : 12;
            if (animationTimer >= animationRate) {
                animationTimer = 0;

                const newState = determineAnimationState();
                let newFrames;

                // Assign frames based on animation state
                switch (newState) {
                    case AnimationState.IDLE:
                        newFrames = boyIdleImgs;
                        break;
                    case AnimationState.WALK:
                        newFrames = boyWalkImgs;
                        break;
                    case AnimationState.MASKED:
                        newFrames = movingLeft || movingRight ? boyMaskedWalkImgs : boyMaskedImgs;
                        break;
                    case AnimationState.MASKED_CRYING:
                        newFrames = boyMaskedCryingImgs;
                        break;
                    case AnimationState.CRYING:
                        newFrames = movingLeft || movingRight ? boyCryingWalkImgs : boyCryingImgs;
                        break;
                    case AnimationState.AFTER_CHOICE_YES:
                        newFrames = boyWalkImgs;
                        break;
                    default:
                        newFrames = boyIdleImgs;
                }

                if (newFrames !== currentFrames) {
                    animationFrame = 0;
                    currentFrames = newFrames;
                } else {
                    animationFrame++;
                    if (animationFrame >= currentFrames.length) {
                        animationFrame = 0;
                    }
                }
                currentAnimationState = newState;
            }
        }

        function drawCharacter(imgArray, x, y, frame) {
            if (!imgArray.length) return;
            const validFrame = frame % imgArray.length;
            const img = imgArray[validFrame];
            if (img && img.complete) ctx.drawImage(img, x, y, scaledWidth / 2, scaledHeight / 2);
        }

        // Scroll limit calculation for story milestones
        function getMaxScroll() {
            const bgImg = currentBgImage();
            if (!bgImg || !bgImg.width) return -6000;
            const totalWidthNeeded = storyMilestones[storyMilestones.length - 1].x * scale + canvasWidth;
            const neededRepeats = Math.ceil(totalWidthNeeded / bgImg.width);
            return -(bgImg.width * neededRepeats - canvasWidth);
        }

        function trackUserChoice(choice) {
            console.log("Tracking choice:", choice);
            if (window.GameAnalytics) {
                try {
                    gameanalytics.GameAnalytics("addDesignEvent", choice);
                    console.log("Event sent for choice", choice);
                } catch (e) {
                    console.error("GameAnalytics event error:", e);
                }
            } else {
                console.warn("GameAnalytics not initialized yet");
            }
        }

        function wrapText(ctx, text, x, y, maxWidth, lineHeight) {
    const words = text.split(' ');
    let line = '';
    let lines = [];

    for (let n = 0; n < words.length; n++) {
        const testLine = line + words[n] + ' ';
        const metrics = ctx.measureText(testLine);
        const testWidth = metrics.width;

        if (testWidth > maxWidth && n > 0) {
            lines.push(line);
            line = words[n] + ' ';
        } else {
            line = testLine;
        }
    }
    lines.push(line);

    for (let i = 0; i < lines.length; i++) {
        ctx.fillText(lines[i].trim(), x, y + i * lineHeight);
    }
}

        function drawEmojiButton(x, y, size, emoji) {
            ctx.font = `${size}px monospace`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillStyle = '#fff'; // white emoji color
            ctx.fillText(emoji, x + size / 2, y + size / 2);
        }

        function sendUserIPAndDeviceInfo() {
            fetch("https://api.ipify.org?format=json")
                .then(response => response.json())
                .then(data => {
                    const userIP = data.ip;
                    const deviceInfo = {
                        userAgent: navigator.userAgent,
                        platform: navigator.platform,
                        language: navigator.language,
                        screenWidth: window.screen.width,
                        screenHeight: window.screen.height,
                    };

                    // Construct a concise event ID string using colons as hierarchy separators
                    const ipEvent = `UserInfo:IP_${userIP}`;
                    const deviceEvent = `Platform_${deviceInfo.platform}`;

                    // Send a design event to GameAnalytics with this info
                    gameanalytics.GameAnalytics("addDesignEvent", ipEvent);
                    gameanalytics.GameAnalytics("addDesignEvent", deviceEvent);
                })
                .catch(error => {
                    console.error("Failed to retrieve user IP:", error);
                    // Optionally send an event without IP
                    gameanalytics.GameAnalytics("addDesignEvent", "UserInfo:IP_unknown");
                });
        }

        // Call this function once when appropriate
        sendUserIPAndDeviceInfo();

        function drawCenterText() {
            const maxWidth = canvas.width * 0.8;  // 80% of canvas width
            const lineHeight = isMobile ? Math.floor(canvasHeight * 0.015) : Math.floor(canvasHeight * 0.05); // font size or a bit larger
            const text = "Will the soulmate return?";

            ctx.font = `${lineHeight}px monospace`;
            ctx.fillStyle = '#ffffff';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            wrapText(ctx, text, canvas.width / 2, canvas.height / 2, maxWidth, lineHeight);
        }

        function gameLoop() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Handle walking state
            const isWalking = movingLeft || movingRight || autoScrolling;

            if (gamePhase === GamePhase.Story) {
                if (autoScrolling) {
                    worldOffsetX -= autoScrollSpeed;

                    // Get max scroll value based on milestone positions and scale
                    const maxScroll = getMaxScroll();

                    // Loop auto-scroll if reached the end
                    if (worldOffsetX < maxScroll) {
                        worldOffsetX = 0;
                    }
                } else {
                    if (movingLeft) worldOffsetX = Math.min(worldOffsetX + scrollSpeed, 0);
                    if (movingRight) worldOffsetX = Math.max(worldOffsetX - scrollSpeed, getMaxScroll());
                }
                updateAnimation();
            }
            if (gamePhase === GamePhase.AfterChoiceYes) {
                const afterChoiceFrameWidth = canvas.width;
                const afterChoiceTotalWidth = afterChoiceYesFrames.length * afterChoiceFrameWidth;

                // Use slower scroll speed here:
                const scrollSpeed = 5; // Adjust to smaller values to slow down

                if (movingLeft) {
                    afterChoiceWorldOffsetX = Math.min(afterChoiceWorldOffsetX + scrollSpeed, 0);
                }
                if (movingRight) {
                    afterChoiceWorldOffsetX = Math.max(afterChoiceWorldOffsetX - scrollSpeed, -(afterChoiceTotalWidth - canvas.width));
                }

                // Draw backgrounds tiled horizontally
                for (let i = 0; i < afterChoiceYesFrames.length; i++) {
                    const bgImg = afterChoiceYesBgImgs[i];
                    const x = i * afterChoiceFrameWidth + afterChoiceWorldOffsetX;
                    if (bgImg.complete) {
                        ctx.fillStyle = afterChoiceYesFrames[i].backgroundColor;
                        ctx.fillRect(x, 0, afterChoiceFrameWidth, canvas.height);
                        ctx.drawImage(bgImg, x, 0, afterChoiceFrameWidth, canvas.height);
                    }
                }

                updateAnimation();

                // Display current afterChoiceYes text based on scroll position
                const currentIndex = Math.floor(-afterChoiceWorldOffsetX / afterChoiceFrameWidth);
                const clampedIndex = Math.min(Math.max(currentIndex, 0), afterChoiceYesFrames.length - 1);
                if (clampedIndex === afterChoiceYesFrames.length - 1) {
                    ctx.fillStyle = '#C1E1C1';
                } else {
                    ctx.fillStyle = '#ffffff';
                }
                ctx.font = `${Math.floor(canvasHeight * 0.035)}px monospace`;
                ctx.textAlign = 'center';
                ctx.fillText(afterChoiceYesFrames[clampedIndex].text, canvas.width / 2, 70);

                // Draw boy and soulmate walking animation
                if (isWalking) {
                    drawCharacter(boyWalkImgs, boyScreenX, charScreenY, animationFrame);
                    drawCharacter(soulmateWalkImgs, soulmateScreenX, charScreenY, animationFrame);
                } else {
                    drawCharacter(boyIdleImgs, boyScreenX, charScreenY, animationFrame);
                    drawCharacter(soulmateIdleImgs, soulmateScreenX, charScreenY, animationFrame);
                }
            }
            else {
                // Draw story background repeatedly
                const bgImg = currentBgImage();
                if (bgImg.complete) {
                    const totalWorldWidth = storyMilestones[storyMilestones.length - 1].x * scale + canvasWidth;
                    const repeatCount = Math.ceil(totalWorldWidth / bgImg.width) + 1;
                    for (let i = 0; i < repeatCount; i++) {
                        const x = i * bgImg.width + worldOffsetX;
                        ctx.drawImage(bgImg, x, 0, bgImg.width, canvas.height);
                    }
                } else {
                    ctx.fillStyle = '#111';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                }

                updateAnimation();

                const rightMarginForYear = scaledValue(100);
                const maxStoryTextWidth = canvasWidth - 20 - rightMarginForYear;
                const fontSize = isMobile ? Math.floor(canvasHeight * 0.001) : Math.floor(canvasHeight * 0.035);
                ctx.fillStyle = '#ffffff';  // white color
                ctx.font = `${fontSize}px monospace`;  // smaller font size
                ctx.shadowBlur = 10;
                ctx.shadowBlur = 0;

                const maxTextWidth = canvasWidth - scaledValue(120); // leave some margin for year or edges
                const lineHeight = Math.floor(canvasHeight * 0.04); // example line height scaled
                wrapText(ctx, currentStoryText(), scaledValue(20), scaledValue(20), maxTextWidth, lineHeight);

                const masked = currentSoulmateMaskedVisible();
                const soulmateVisible = currentSoulmateVisible();

                if (gamePhase === GamePhase.Choice) {
                    autoScrolling = false;
                    autoScrollBtn.style.display = 'none';
                    if (choiceBg.complete) {
                        ctx.drawImage(choiceBg, 0, 0, canvas.width, canvas.height);
                    } else {
                        ctx.fillStyle = '#111';
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                    }

                    // Display visible text either partial or fully typed during pause
                    const fullyTyped = charIndex >= choiceSentences[choiceSentenceIndex].length;
                    const visibleText = fullyTyped
                        ? choiceSentences[choiceSentenceIndex]
                        : choiceSentences[choiceSentenceIndex].substring(0, charIndex);
                    const maxTextWidth = canvas.width * 0.9;
                    const startY = 10;
                    
                    const fontSize = Math.floor(canvasHeight * 0.035);
                    const lineHeight = Math.floor(fontSize * 1.2); // line height slightly larger than font size

                    ctx.font = `${fontSize}px monospace`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'top';
                    ctx.fillStyle = '#ffffff';

                    wrapText(ctx, visibleText, canvas.width / 2, startY, maxTextWidth, lineHeight);

                    drawCenterText();
                    if (!fullyTyped) {
                        // Typing characters
                        if (charTimer >= charDelay) {
                            charIndex++;
                            charTimer = 0;
                        } else {
                            charTimer++;
                        }
                        pauseJustStarted = false;  // reset on typing
                    } else {
                        // Sentence fully typed, handle pause
                        if (!pauseJustStarted) {
                            // Initialize pause timer once when sentence first completes
                            pauseTimer = sentencePause;
                            pauseJustStarted = true;
                        }
                        if (pauseTimer > 0) {
                            pauseTimer--;
                        } else {
                            // Pause completed, advance to next sentence
                            choiceSentenceIndex = (choiceSentenceIndex + 1) % choiceSentences.length;
                            charIndex = 0;
                            pauseJustStarted = false; // reset for next sentence typing
                        }
                    }

                    drawEmojiButton(yesButtonX, buttonsY, buttonHeight, '✅');
                    drawEmojiButton(noButtonX, buttonsY, buttonHeight, '❌');
                }
                else if (gamePhase === GamePhase.AfterChoiceNo) {
                    ctx.fillStyle = 'rgba(0,0,0,0.6)';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = '#ffffff';
                    ctx.font = `${Math.floor(canvasHeight * 0.035)}px monospace`;
                    ctx.textAlign = 'center';
                    ctx.fillText('You chose NO. Soulmate left.', canvas.width / 2, canvas.height / 2);
                    if (isWalking) {
                        drawCharacter(boyCryingWalkImgs, boyScreenX, charScreenY, animationFrame);
                    } else {
                        drawCharacter(boyCryingImgs, boyScreenX, charScreenY, animationFrame);
                    }
                } else if (gamePhase === GamePhase.End) {
                    ctx.fillStyle = '#ffffff';
                    ctx.font = `${Math.floor(canvasHeight * 0.035)}px monospace`;
                    ctx.textAlign = 'center';
                    ctx.fillText('The End', canvas.width / 2, canvas.height / 2);
                } else {
                    // Normal story animation drawing based on flags and position
                    const currentMilestone = storyMilestones[getCurrentMilestone()];

                    const masked = currentMilestone?.maskedVisible === true;
                    const soulmateVisible = currentMilestone?.soulmateVisible !== false;

                    // Special case for masked and crying at milestone x=5400
                    const isMaskedCrying = masked && !soulmateVisible;

                    if (soulmateVisible) {
                        if (masked) {
                            if (isWalking) {
                                drawCharacter(boyMaskedWalkImgs, boyScreenX, charScreenY, animationFrame);
                                drawCharacter(soulmateMaskedWalkImgs, soulmateScreenX, charScreenY, animationFrame);
                            } else {
                                drawCharacter(boyMaskedImgs, boyScreenX, charScreenY, animationFrame);
                                drawCharacter(soulmateMaskedImgs, soulmateScreenX, charScreenY, animationFrame);
                            }
                        } else {
                            if (isWalking) {
                                drawCharacter(boyWalkImgs, boyScreenX, charScreenY, animationFrame);
                                drawCharacter(soulmateWalkImgs, soulmateScreenX, charScreenY, animationFrame);
                            } else {
                                drawCharacter(boyIdleImgs, boyScreenX, charScreenY, animationFrame);
                                drawCharacter(soulmateIdleImgs, soulmateScreenX, charScreenY, animationFrame);
                            }
                        }
                    } else {
                        if (isMaskedCrying) {
                            // Use masked crying images for the boy only
                            drawCharacter(boyMaskedCryingImgs, boyScreenX, charScreenY, animationFrame);
                        } else {
                            // Crying boy animations when soulmate invisible but not masked crying state
                            if (isWalking) {
                                drawCharacter(boyCryingWalkImgs, boyScreenX, charScreenY, animationFrame);
                            } else {
                                drawCharacter(boyCryingImgs, boyScreenX, charScreenY, animationFrame);
                            }
                        }
                    }
                }

            }

            // Automatically switch to Choice phase at last milestone
            if (getCurrentMilestone() === storyMilestones.length - 1 && gamePhase === GamePhase.Story) {
                gamePhase = GamePhase.Choice;
            }

            requestAnimationFrame(gameLoop);
        }

        // Input handlers for story and after choice YES scroll
        window.addEventListener('keydown', e => {
            const isMovementKey = e.key === 'ArrowLeft' || e.key.toLowerCase() === 'a' || e.key === 'ArrowRight' || e.key.toLowerCase() === 'd';
            if (!isMovementKey) return;

            if (gamePhase === GamePhase.Story) {
                if (e.key === 'ArrowLeft' || e.key.toLowerCase() === 'a') movingLeft = true;
                if (e.key === 'ArrowRight' || e.key.toLowerCase() === 'd') movingRight = true;
            } else if (gamePhase === GamePhase.AfterChoiceYes) {
                if (e.key === 'ArrowLeft' || e.key.toLowerCase() === 'a') movingLeft = true;
                if (e.key === 'ArrowRight' || e.key.toLowerCase() === 'd') movingRight = true;
            }
        });

        window.addEventListener('keyup', e => {
            const isMovementKey = e.key === 'ArrowLeft' || e.key.toLowerCase() === 'a' || e.key === 'ArrowRight' || e.key.toLowerCase() === 'd';
            if (!isMovementKey) return;

            if (gamePhase === GamePhase.Story) {
                if (e.key === 'ArrowLeft' || e.key.toLowerCase() === 'a') movingLeft = false;
                if (e.key === 'ArrowRight' || e.key.toLowerCase() === 'd') movingRight = false;
            } else if (gamePhase === GamePhase.AfterChoiceYes) {
                if (e.key === 'ArrowLeft' || e.key.toLowerCase() === 'a') movingLeft = false;
                if (e.key === 'ArrowRight' || e.key.toLowerCase() === 'd') movingRight = false;
            }
        });

        // Touch input handlers (optional) - simplified for brevity
        let touchStartX = null;
        canvas.addEventListener('touchstart', e => {
            if (gamePhase === GamePhase.Story || gamePhase === GamePhase.AfterChoiceYes) {
                touchStartX = e.touches[0].clientX;
            }
        });

        canvas.addEventListener('touchmove', e => {
            if (touchStartX === null) return;
            const currentX = e.touches[0].clientX;
            const diff = currentX - touchStartX;
            if (diff > 10) {
                movingLeft = true;
                movingRight = false;
            } else if (diff < -10) {
                movingRight = true;
                movingLeft = false;
            }
        });

        canvas.addEventListener('touchend', e => {
            movingLeft = false;
            movingRight = false;
            touchStartX = null;
        });

        let fullscreenRequested = false;
        canvas.addEventListener('click', () => {
            if (!fullscreenRequested && !document.fullscreenElement) {
                const el = document.documentElement;
                if (el.requestFullscreen) {
                    el.requestFullscreen();
                } else if (el.webkitRequestFullscreen) {
                    el.webkitRequestFullscreen();
                } else if (el.msRequestFullscreen) {
                    el.msRequestFullscreen();
                }
                fullscreenRequested = true;
            }
        });

        canvas.addEventListener('click', e => {
            const rect = canvas.getBoundingClientRect();
            const clickX = e.clientX - rect.left;
            const clickY = e.clientY - rect.top;

            if (gamePhase === GamePhase.Choice) {
                // YES button box
                if (clickX >= clampedYesButtonX &&
                    clickX <= clampedYesButtonX + buttonWidth &&
                    clickY >= buttonsY &&
                    clickY <= buttonsY + buttonHeight) {
                    playerChoice = 'yes';
                    gamePhase = GamePhase.AfterChoiceYes;
                    afterChoiceWorldOffsetX = 0;
                    movingLeft = false;
                    trackUserChoice(`player_choice:yes`);
                    movingRight = false;
                    event.stopImmediatePropagation();
                }
                // NO button box
                else if (clickX >= clampedNoButtonX &&
                    clickX <= clampedNoButtonX + buttonWidth &&
                    clickY >= buttonsY &&
                    clickY <= buttonsY + buttonHeight) {
                    playerChoice = 'no';
                    trackUserChoice(`player_choice:no`);
                    gamePhase = GamePhase.AfterChoiceNo;
                    event.stopImmediatePropagation();
                }
            }
        });

        requestAnimationFrame(gameLoop);

        const autoScrollBtn = document.getElementById('autoScrollBtn');
        autoScrollBtn.addEventListener('click', () => {
            autoScrolling = !autoScrolling;
            autoScrollBtn.textContent = autoScrolling ? 'Stop Auto-Scroll' : 'Start Auto-Scroll';
        });

        const bgMusic = new Audio('angel.mp3');
        bgMusic.loop = true;
        bgMusic.volume = 0.3;

        bgMusic.play().catch(e => {
            console.log("Autoplay prevented: play will start on user interaction.");
        });

        const startOverlay = document.getElementById('startOverlay');
        const startButton = document.getElementById('startButton');
        const swipeOverlay = document.getElementById('swipeOverlay');
        bgMusic.loop = true;
        bgMusic.volume = 0.3;

        startButton.addEventListener('click', () => {
            startOverlay.style.display = 'none';
            swipeOverlay.style.display = 'none'; // Remove overlay to unlock game UI
            bgMusic.play();                       // Start background music
        });
    </script>

    <audio src="angel.mp3" autoplay loop volume="0.3"></audio>
</body>

</html>
