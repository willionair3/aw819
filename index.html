<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>awSince1984</title>
  <style>
    body { margin: 0; overflow: hidden; background: #111; }
    canvas { display: block; margin: auto; background: #111; touch-action: none; }
  </style>
</head>
<body>

<canvas id="gameCanvas" width="800" height="400"></canvas>

<!-- GameAnalytics SDK -->
<script>
  (function(w,d,s,u){
    w['GameAnalytics'] = w['GameAnalytics'] || function(){(w['GameAnalytics'].q = w['GameAnalytics'].q || []).push(arguments)};
    var ga = d.createElement(s), m = d.getElementsByTagName(s)[0];
    ga.async = 1;
    ga.src = u;
    m.parentNode.insertBefore(ga,m);
  })(window,document,'script','https://download.gameanalytics.com/js/GameAnalytics.latest.min.js');

  GameAnalytics("setEnabledInfoLog", true);
  GameAnalytics("initialize", "74d3259c304d64ec6ad15574eb975019", "d9212b3ec2f73ae0648888f637774c1b8b455bcf");
</script>

<script>
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');

  // Frames
  const boyIdleFrames = ['pixel_boy_idle_1.png', 'pixel_boy_idle_2.png', 'pixel_boy_idle_3.png'];
  const boyCryingFrames = ['pixel_boy_crying_1.png', 'pixel_boy_crying_2.png', 'pixel_boy_crying_3.png'];
  const soulmateIdleFrames = ['pixel_soulmate_idle_1.png', 'pixel_soulmate_idle_2.png', 'pixel_soulmate_idle_3.png'];

  function preloadFrames(urls) {
    return urls.map(url => {
      const img = new Image();
      img.src = url;
      return img;
    });
  }

  const boyIdleImgs = preloadFrames(boyIdleFrames);
  const boyCryingImgs = preloadFrames(boyCryingFrames);
  const soulmateIdleImgs = preloadFrames(soulmateIdleFrames);

  const frameWidth = 40;
  const frameHeight = 60;
  const scale = 4;
  const scaledWidth = frameWidth * scale;
  const scaledHeight = frameHeight * scale;

  const canvasWidth = canvas.width;
  const canvasHeight = canvas.height;

  // Background images for 2011 and others
  const bg_sf = new Image();
  bg_sf.src = 'pixel_sf.png';
  const bg_hk = new Image();
  bg_hk.src = 'pixel_hk.png';

  // After choice YES city frames
  const afterChoiceYesFrames = [
    { backgroundColor: '#f5f0e6', text: "Budapest: A new journey begins.", bgImageSrc: 'pixel_budapest.png' },
    { backgroundColor: '#d0d7de', text: "Prague: Exploring ancient streets.", bgImageSrc: 'pixel_prague.png' },
    { backgroundColor: '#f0e68c', text: "India: A land of colors and wonders.", bgImageSrc: 'pixel_india.png' },
    { backgroundColor: '#f0e68c', text: "Mexico: The land of tacos.", bgImageSrc: 'pixel_mexico.png' },
    { backgroundColor: '#add8e6', text: "Seoul: Embracing new horizons.", bgImageSrc: 'pixel_seoul.png' },
    { backgroundColor: '#add8e6', text: "Berlin: Reminiscing moments.", bgImageSrc: 'pixel_berlin.png' },
    { backgroundColor: '#add8e6', text: "Taipei: Heartfelt memories.", bgImageSrc: 'pixel_taipei.png' },
    { backgroundColor: '#add8e6', text: "Zurich: Comfort and peace.", bgImageSrc: 'pixel_zurich.png' },
    { backgroundColor: '#add8e6', text: "Paris: Timeless love.", bgImageSrc: 'pixel_paris.png' },
    { backgroundColor: '#add8e6', text: "Beijing: Strength through challenges.", bgImageSrc: 'pixel_beijing.png' },
    { backgroundColor: '#add8e6', text: "Osaka: Resilience remains.", bgImageSrc: 'pixel_osaka.png' },
    { backgroundColor: '#add8e6', text: "Tokyo: Never giving up.", bgImageSrc: 'pixel_tokyo.png' },
    { backgroundColor: '#add8e6', text: "Hong Kong: Home forever.", bgImageSrc: 'pixel_hk.png' },
    { backgroundColor: '#add8e6', text: "Earth: Infinite adventures around the globe.", bgImageSrc: 'pixel_earth.png' }
  ];

  // Story milestones and soulmate visibility with backgrounds
  const storyMilestones = [
    { x: 0, text: "The boy starts the year filled with hope.", soulmateVisible: true, bg: 'sf' },
    { x: 150, text: "In August 2011 they start dating officially.", soulmateVisible: true, bg: 'sf' },
    { x: 300, text: "Separated August to December 2011.", soulmateVisible: false, bg: 'sf' },
    { x: 450, text: "Reunited after December 2011.", soulmateVisible: true, bg: 'hk' },
    { x: 600, text: "Friends grow closer, hearts grow fonder.", soulmateVisible: true, bg: 'hk' },
    { x: 900, text: "Love deepens over time.", soulmateVisible: true, bg: 'hk' },
    { x: 1200, text: "Preparing for a joyful future.", soulmateVisible: true, bg: 'hk' },
    { x: 1500, text: "Wedding day surrounded by love.", soulmateVisible: true, bg: 'hk' },
    { x: 1800, text: "Life brings many adventures.", soulmateVisible: true, bg: 'hk' },
    { x: 2100, text: "Cherished moments together.", soulmateVisible: true, bg: 'hk' },
    { x: 2400, text: "Overcoming challenges with strength.", soulmateVisible: true, bg: 'hk' },
    { x: 2700, text: "Tough times in September 2019.", soulmateVisible: false, bg: 'hk' },
    { x: 3000, text: "Reunited after November 2019.", soulmateVisible: true, bg: 'hk' },
    { x: 3300, text: "A world changed, faces masked.", soulmateVisible: true, bg: 'hk' },
    { x: 3600, text: "Hope grows anew.", soulmateVisible: true, bg: 'hk' },
    { x: 3900, text: "New beginnings in a new home.", soulmateVisible: true, bg: 'hk' },
    { x: 4200, text: "Dreams and doubts meet.", soulmateVisible: true, bg: 'hk' },
    { x: 4500, text: "Uncertainty looms.", soulmateVisible: true, bg: 'hk' },
    { x: 4800, text: "August 2025 - Marriage at crossroads.", soulmateVisible: false, bg: 'hk' },
    { x: 5100, text: "Reunited after August 2025.", soulmateVisible: true, bg: 'hk' },
    { x: 5400, text: "Ending story.", soulmateVisible: true, bg: 'hk' },
  ];

  const GamePhase = {
    Story: 0,
    Choice: 1,
    AfterChoiceYes: 2,
    AfterChoiceNo: 3,
    End: 4,
  };

  let gamePhase = GamePhase.Story;
  let playerChoice = null;

  // After choice Yes city frame index
  let afterChoiceYesIndex = 0;

  function getCurrentMilestone() {
    for (let i = storyMilestones.length - 1; i >= 0; i--) {
      if (worldOffsetX >= storyMilestones[i].x) return i;
    }
    return 0;
  }

  function currentSoulmateVisible() {
    if (gamePhase === GamePhase.Choice || gamePhase === GamePhase.AfterChoiceNo) return false;
    if (gamePhase === GamePhase.AfterChoiceYes) return true; // soulmate back
    const index = getCurrentMilestone();
    return storyMilestones[index].soulmateVisible;
  }

  function currentBgImage(){
    const index = getCurrentMilestone();
    const bgType = storyMilestones[index].bg;
    if(bgType === 'sf') return bg_sf;
    return bg_hk;
  }

  function currentStoryText() {
    if (gamePhase === GamePhase.AfterChoiceYes) {
      return afterChoiceYesFrames[afterChoiceYesIndex].text;
    }
    const index = getCurrentMilestone();
    return storyMilestones[index].text;
  }

  const scrollSpeed = 9; // Faster movement pace
  let worldOffsetX = 0;

  const boyScreenX = 200;
  const soulmateScreenX = boyScreenX + scaledWidth + 20;
  const charScreenY = 120;

  let animationFrame = 0;
  let animationTimer = 0;
  const animationSpeed = 12;

  let movingLeft = false;
  let movingRight = false;

  // Preload afterChoiceYes background images
  const afterChoiceYesBgImgs = [];
  for(const frame of afterChoiceYesFrames) {
    const img = new Image();
    img.src = frame.bgImageSrc;
    afterChoiceYesBgImgs.push(img);
  }

  function updateAnimation() {
    animationTimer++;
    if (animationTimer >= animationSpeed) {
      animationTimer = 0;
      animationFrame = (animationFrame + 1) % boyIdleImgs.length;
    }
  }

  function drawCharacter(imgArray, x, y, frame) {
    if (!imgArray.length) return;
    const img = imgArray[frame];
    if (img.complete) {
      ctx.drawImage(img, x, y, scaledWidth, scaledHeight);
    }
  }

  function gameLoop() {
    ctx.clearRect(0, 0, canvasWidth, canvasHeight);

    if (gamePhase === GamePhase.Story) {
      if (movingLeft) {
        worldOffsetX = Math.min(worldOffsetX + scrollSpeed, 0);
      }
      if (movingRight) {
        const maxRight = - (currentBgImage().width * 3 - canvasWidth);
        worldOffsetX = Math.max(worldOffsetX - scrollSpeed, maxRight);
      }
    }

    if (gamePhase === GamePhase.Story || gamePhase === GamePhase.Choice || gamePhase === GamePhase.AfterChoiceNo) {
      // Background for main story and choice/no scenes
      const bgImg = currentBgImage();
      if (bgImg.complete) {
        for(let i = -Math.floor((-worldOffsetX)/bgImg.width)-1; i <= Math.ceil(canvasWidth/bgImg.width); i++) {
          ctx.drawImage(bgImg, i*bgImg.width + worldOffsetX, 0, bgImg.width, canvasHeight);
        }
      } else {
        ctx.fillStyle = '#111';
        ctx.fillRect(0, 0, canvasWidth, canvasHeight);
      }
    } else if (gamePhase === GamePhase.AfterChoiceYes) {
      // Background from afterChoiceYes frames for current index
      let bgImg = afterChoiceYesBgImgs[afterChoiceYesIndex];
      if (bgImg.complete) {
        ctx.drawImage(bgImg, 0, 0, canvasWidth, canvasHeight);
      } else {
        ctx.fillStyle = afterChoiceYesFrames[afterChoiceYesIndex].backgroundColor;
        ctx.fillRect(0, 0, canvasWidth, canvasHeight);
      }
    }

    updateAnimation();

    ctx.fillStyle = '#39ff14';
    ctx.font = '28px monospace';
    ctx.shadowColor = '#39ff14';
    ctx.shadowBlur = 10;
    ctx.fillText(currentStoryText(), 20, 70);
    ctx.shadowBlur = 0;

    if (gamePhase === GamePhase.AfterChoiceYes) {
      // Always show couple together near each other in afterChoiceYes frames
      drawCharacter(boyIdleImgs, boyScreenX, charScreenY, animationFrame);
      drawCharacter(soulmateIdleImgs, soulmateScreenX, charScreenY, animationFrame);
    } else if (currentSoulmateVisible()) {
      drawCharacter(boyIdleImgs, boyScreenX, charScreenY, animationFrame);
      drawCharacter(soulmateIdleImgs, soulmateScreenX, charScreenY, animationFrame);
    } else {
      drawCharacter(boyCryingImgs, boyScreenX, charScreenY, animationFrame);
    }

    if (getCurrentMilestone() === storyMilestones.length - 1 && gamePhase === GamePhase.Story) {
      gamePhase = GamePhase.Choice;
    }

    if (gamePhase === GamePhase.Choice) {
      ctx.fillStyle = 'rgba(0,0,0,0.7)';
      ctx.fillRect(0, 0, canvasWidth, canvasHeight);
      ctx.fillStyle = '#39ff14';
      ctx.font = '36px monospace';
      ctx.textAlign = 'center';
      ctx.fillText("Should the soulmate return?", canvasWidth / 2, canvasHeight / 2 - 40);

      drawButton(canvasWidth / 2 - 140, canvasHeight / 2, 120, 60, '#39ff14', '#000', 'YES');
      drawButton(canvasWidth / 2 + 20, canvasHeight / 2, 120, 60, '#f33914', '#000', 'NO');
    }

    // After choice yes - frames navigation
    if (gamePhase === GamePhase.AfterChoiceYes) {
      ctx.fillStyle = '#39ff14';
      ctx.font = '24px monospace';
      ctx.textAlign = 'center';
      ctx.fillText(`Swipe or tap to continue (${afterChoiceYesIndex + 1}/${afterChoiceYesFrames.length})`, canvasWidth / 2, canvasHeight - 30);
    }

    if (gamePhase === GamePhase.AfterChoiceNo) {
      ctx.fillStyle = 'rgba(0,0,0,0.6)';
      ctx.fillRect(0, 0, canvasWidth, canvasHeight);
      ctx.fillStyle = '#39ff14';
      ctx.font = '36px monospace';
      ctx.textAlign = 'center';
      ctx.fillText("You chose NO. Soulmate left.", canvasWidth / 2, canvasHeight / 2);
      drawCharacter(boyCryingImgs, boyScreenX, charScreenY, animationFrame);
    }

    if (gamePhase === GamePhase.End) {
      ctx.fillStyle = '#39ff14';
      ctx.font = '40px monospace';
      ctx.textAlign = 'center';
      ctx.fillText('The End', canvasWidth / 2, canvasHeight / 2);
    }

    requestAnimationFrame(gameLoop);
  }

  function drawButton(x, y, w, h, fill, textColor, text) {
    ctx.fillStyle = fill;
    ctx.fillRect(x, y, w, h);
    ctx.fillStyle = textColor;
    ctx.font = '28px monospace';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(text, x + w/2, y + h/2);
  }

  window.addEventListener('keydown', e => {
    if (gamePhase === GamePhase.Story) {
      if (e.key === 'ArrowLeft' || e.key.toLowerCase() === 'a') movingLeft = true;
      if (e.key === 'ArrowRight' || e.key.toLowerCase() === 'd') movingRight = true;
    }
  });

  window.addEventListener('keyup', e => {
    if (gamePhase === GamePhase.Story) {
      if (e.key === 'ArrowLeft' || e.key.toLowerCase() === 'a') movingLeft = false;
      if (e.key === 'ArrowRight' || e.key.toLowerCase() === 'd') movingRight = false;
    }
  });

  let movingLeft = false;
  let movingRight = false;

  // Mobile touch controls for story scrolling
  let touchStartX = null;
  canvas.addEventListener('touchstart', e => {
    if (gamePhase === GamePhase.Story) {
      touchStartX = e.touches[0].clientX;
    }
  });

  canvas.addEventListener('touchmove', e => {
    if (touchStartX === null) return;
    const currentX = e.touches[0].clientX;
    const diff = currentX - touchStartX;

    if (diff > 10) {
      movingLeft = true;
      movingRight = false;
    } else if (diff < -10) {
      movingRight = true;
      movingLeft = false;
    }
  });

  canvas.addEventListener('touchend', e => {
    movingLeft = false;
    movingRight = false;
    touchStartX = null;
  });

  // Choice buttons click
  canvas.addEventListener('click', e => {
    const rect = canvas.getBoundingClientRect();
    const clickX = e.clientX - rect.left;
    const clickY = e.clientY - rect.top;

    if (gamePhase === GamePhase.Choice) {
      if (clickX >= canvasWidth / 2 - 140 && clickX <= canvasWidth / 2 - 20 &&
          clickY >= canvasHeight / 2 && clickY <= canvasHeight / 2 + 60) {
        playerChoice = 'yes';
        GameAnalytics("addDesignEvent", `player_choice:yes`);
        gamePhase = GamePhase.AfterChoiceYes;
        afterChoiceYesIndex = 0;
      } else if (clickX >= canvasWidth / 2 + 20 && clickX <= canvasWidth / 2 + 140 &&
                 clickY >= canvasHeight / 2 && clickY <= canvasHeight / 2 + 60) {
        playerChoice = 'no';
        GameAnalytics("addDesignEvent", `player_choice:no`);
        gamePhase = GamePhase.AfterChoiceNo;
      }
    } else if (gamePhase === GamePhase.AfterChoiceYes) {
      // On tap go to next city frame or end
      afterChoiceYesIndex++;
      if (afterChoiceYesIndex >= afterChoiceYesFrames.length) {
        gamePhase = GamePhase.End;
      }
    }
  });

  // Optional: swipe left/right to navigate afterChoiceYes frames (advanced)
  let afterChoiceTouchStartX = null;
  canvas.addEventListener('touchstart', e => {
    if (gamePhase === GamePhase.AfterChoiceYes) {
      afterChoiceTouchStartX = e.touches[0].clientX;
    }
  });
  canvas.addEventListener('touchend', e => {
    if (gamePhase === GamePhase.AfterChoiceYes && afterChoiceTouchStartX !== null) {
      const touchEndX = e.changedTouches[0].clientX;
      const deltaX = touchEndX - afterChoiceTouchStartX;
      afterChoiceTouchStartX = null;
      if (deltaX < -30) { // swipe left advance
        afterChoiceYesIndex++;
        if (afterChoiceYesIndex >= afterChoiceYesFrames.length) {
          gamePhase = GamePhase.End;
        }
      } else if (deltaX > 30) { // swipe right go back if desired
        if (afterChoiceYesIndex > 0) afterChoiceYesIndex--;
      }
    }
  });

  gameLoop();
</script>

</body>
</html>
