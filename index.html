<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <title>awSince1984</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #111;
        }

        canvas {
            display: block;
            margin: auto;
            background: #111;
            touch-action: none;
        }
    </style>
</head>

<body>

    <canvas id="gameCanvas" width="800" height="400"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Frame dimensions and scale
        const frameWidth = 40;
        const frameHeight = 60;
        const scale = 4;
        const scaledWidth = frameWidth * scale;
        const scaledHeight = frameHeight * scale;
        // === Add near the top with your other globals ===

        // === Add these variables for choice screen fade and typing effect ===
        let fadeAlpha = 0;
        const fadeIncrement = 0.02;
        let choiceSentenceIndex = 0;
        let charIndex = 0;
        let charTimer = 0;
        const charDelay = 22;
        const sentencePause = 500;
        let pauseTimer = 0;

        const choiceSentences = [
            "how can you wait for someone who might never come back?",
            "because I know you're worth the risk",
            "what if I end up breaking your heart?",
            "then i will be a broken heart that loved you fully. i dont expect you to promise me anything - not a timeframe, not even certainty. i'll wait because i'd rather spend my life hoping for you than living without you. and even if you never come back, i will still be glad i waited. because some people are worth it, and you're one of them"
        ];

        const choiceBg = new Image();
        choiceBg.src = 'background_hk.png';  // Your choice screen background image

        // Animation frame arrays
        const boyIdleFrames = ['pixel_boy_idle_1.png', 'pixel_boy_idle_2.png', 'pixel_boy_idle_3.png'];
        const boyWalkFrames = ['pixel_boy_walk_1.png', 'pixel_boy_walk_2.png', 'pixel_boy_walk_3.png', 'pixel_boy_walk_4.png'];
        const boyCryingFrames = ['pixel_boy_crying_1.png', 'pixel_boy_crying_2.png', 'pixel_boy_crying_3.png'];
        const boyCryingWalkFrames = ['pixel_boy_crying_walk_1.png', 'pixel_boy_crying_walk_2.png', 'pixel_boy_crying_walk_3.png', 'pixel_boy_crying_walk_4.png'];

        const soulmateIdleFrames = ['pixel_soulmate_idle_1.png', 'pixel_soulmate_idle_2.png', 'pixel_soulmate_idle_3.png'];
        const soulmateWalkFrames = ['pixel_soulmate_walk_1.png', 'pixel_soulmate_walk_2.png', 'pixel_soulmate_walk_3.png', 'pixel_soulmate_walk_4.png'];

        const boyMaskedFrames = ['pixel_boy_masked_1.png', 'pixel_boy_masked_2.png', 'pixel_boy_masked_3.png'];
        const soulmateMaskedFrames = ['pixel_soulmate_masked_1.png', 'pixel_soulmate_masked_2.png', 'pixel_soulmate_masked_3.png'];

        const boyMaskedWalkFrames = ['pixel_boy_masked_walk_1.png', 'pixel_boy_masked_walk_2.png', 'pixel_boy_masked_walk_3.png', 'pixel_boy_masked_walk_4.png'];
        const soulmateMaskedWalkFrames = ['pixel_soulmate_masked_walk_1.png', 'pixel_soulmate_masked_walk_2.png', 'pixel_soulmate_masked_walk_3.png', 'pixel_soulmate_masked_walk_4.png'];

        const afterChoiceYesFrames = [
            { backgroundColor: '#f5f0e6', text: "Budapest: A new journey begins.", bgImageSrc: 'pixel_budapest.png' },
            { backgroundColor: '#d0d7de', text: "Prague: Exploring ancient streets.", bgImageSrc: 'pixel_prague.png' },
            { backgroundColor: '#f0e68c', text: "India: A land of colors and wonders.", bgImageSrc: 'pixel_india.png' },
            { backgroundColor: '#f0e68c', text: "Mexico: The land of tacos.", bgImageSrc: 'pixel_mexico.png' },
            { backgroundColor: '#add8e6', text: "Seoul: Embracing new horizons.", bgImageSrc: 'pixel_seoul.png' },
            { backgroundColor: '#add8e6', text: "Berlin: Reminiscing moments.", bgImageSrc: 'pixel_berlin.png' },
            { backgroundColor: '#add8e6', text: "Taipei: Heartfelt memories.", bgImageSrc: 'pixel_taipei.png' },
            { backgroundColor: '#add8e6', text: "Zurich: Comfort and peace.", bgImageSrc: 'pixel_zurich.png' },
            { backgroundColor: '#add8e6', text: "Paris: Timeless love.", bgImageSrc: 'pixel_paris.png' },
            { backgroundColor: '#add8e6', text: "Beijing: Strength through challenges.", bgImageSrc: 'pixel_beijing.png' },
            { backgroundColor: '#add8e6', text: "Osaka: Resilience remains.", bgImageSrc: 'pixel_osaka.png' },
            { backgroundColor: '#add8e6', text: "Tokyo: Never giving up.", bgImageSrc: 'pixel_tokyo.png' },
            { backgroundColor: '#add8e6', text: "Hong Kong: Home forever.", bgImageSrc: 'pixel_hk.png' },
            { backgroundColor: '#add8e6', text: "Earth: Infinite adventures around the globe.", bgImageSrc: 'pixel_earth.png' }
        ];

        const storyMilestones = [
            { x: 0, text: "The boy starts the year filled with hope.", soulmateVisible: true, bg: 'sf' },
            { x: 150, text: "In August 2011 they start dating officially.", soulmateVisible: true, bg: 'sf' },
            { x: 300, text: "Separated August to December 2011.", soulmateVisible: false, bg: 'sf' },
            { x: 450, text: "Reunited after December 2011.", soulmateVisible: true, bg: 'hk' },
            { x: 600, text: "Friends grow closer, hearts grow fonder.", soulmateVisible: true, bg: 'hk' },
            { x: 900, text: "Love deepens over time.", soulmateVisible: true, bg: 'hk' },
            { x: 1200, text: "Preparing for a joyful future.", soulmateVisible: true, bg: 'hk' },
            { x: 1500, text: "Wedding day surrounded by love.", soulmateVisible: true, bg: 'hk' },
            { x: 1800, text: "Life brings many adventures.", soulmateVisible: true, bg: 'hk' },
            { x: 2100, text: "Cherished moments together.", soulmateVisible: true, bg: 'hk' },
            { x: 2400, text: "Overcoming challenges with strength.", soulmateVisible: true, bg: 'hk' },
            { x: 2700, text: "Tough times in September 2019.", soulmateVisible: false, bg: 'hk' },
            { x: 3000, text: "Reunited after November 2019.", soulmateVisible: true, bg: 'hk' },
            { x: 3300, text: "A world changed, faces masked.", soulmateVisible: true, bg: 'hk', maskedVisible: true },
            { x: 3600, text: "Hope grows anew.", soulmateVisible: true, bg: 'hk' },
            { x: 3900, text: "New beginnings in a new home.", soulmateVisible: true, bg: 'hk' },
            { x: 4200, text: "Dreams and doubts meet.", soulmateVisible: true, bg: 'hk' },
            { x: 4500, text: "Uncertainty looms.", soulmateVisible: true, bg: 'hk' },
            { x: 4800, text: "August 2025 - Marriage at crossroads.", soulmateVisible: false, bg: 'hk' },
            { x: 5100, text: "Reunited after August 2025.", soulmateVisible: true, bg: 'hk' },
            { x: 5400, text: "Ending story.", soulmateVisible: true, bg: 'hk' },
        ];

        const GamePhase = { Story: 0, Choice: 1, AfterChoiceYes: 2, AfterChoiceNo: 3, End: 4 };
        let gamePhase = GamePhase.Story;
        let playerChoice = null;
        let afterChoiceYesIndex = 0;
        let worldOffsetX = 0;

        // New scroll offset for afterChoiceYes frames
        let afterChoiceWorldOffsetX = 0;

        const scrollSpeed = 9;
        const boyScreenX = 200;
        const soulmateScreenX = boyScreenX + scaledWidth + 20;
        const charScreenY = 120;

        let animationFrame = 0;
        let animationTimer = 0;
        let previousFrames = null;

        let movingLeft = false;
        let movingRight = false;

        // Load backgrounds
        const bg_sf = new Image(); bg_sf.src = 'pixel_sf.png';
        const bg_hk = new Image(); bg_hk.src = 'pixel_hk.png';

        // After choice YES backgrounds
        const afterChoiceYesBgImgs = afterChoiceYesFrames.map(frame => {
            const img = new Image();
            img.src = frame.bgImageSrc;
            return img;
        });

        function preloadFrames(urls) {
            return urls.map(url => {
                const img = new Image();
                img.src = url;
                return img;
            });
        }

        // Load sprite frames
        const boyIdleImgs = preloadFrames(boyIdleFrames);
        const boyWalkImgs = preloadFrames(boyWalkFrames);
        const boyCryingImgs = preloadFrames(boyCryingFrames);
        const boyCryingWalkImgs = preloadFrames(boyCryingWalkFrames);
        const soulmateIdleImgs = preloadFrames(soulmateIdleFrames);
        const soulmateWalkImgs = preloadFrames(soulmateWalkFrames);
        const boyMaskedImgs = preloadFrames(boyMaskedFrames);
        const soulmateMaskedImgs = preloadFrames(soulmateMaskedFrames);
        const boyMaskedWalkImgs = preloadFrames(boyMaskedWalkFrames);
        const soulmateMaskedWalkImgs = preloadFrames(soulmateMaskedWalkFrames);

        // Asset loading tracker
        const assets = [
            bg_sf, bg_hk,
            ...boyIdleImgs, ...boyWalkImgs, ...boyCryingImgs, ...boyCryingWalkImgs,
            ...soulmateIdleImgs, ...soulmateWalkImgs,
            ...boyMaskedImgs, ...soulmateMaskedImgs,
            ...boyMaskedWalkImgs, ...soulmateMaskedWalkImgs,
            ...afterChoiceYesBgImgs
        ];

        let assetsLoaded = 0;
        assets.forEach(img => img.onload = () => {
            assetsLoaded++;
            if (assetsLoaded === assets.length) {
                console.log("All assets loaded, starting game.");
                requestAnimationFrame(gameLoop);
            }
        });

        // Calculate the positive offset for milestone checking
        function getCurrentMilestone() {
            const positiveOffset = -worldOffsetX;
            for (let i = storyMilestones.length - 1; i >= 0; i--) {
                if (positiveOffset >= storyMilestones[i].x) return i;
            }
            return 0;
        }

        function currentBgImage() {
            const idx = getCurrentMilestone();
            return storyMilestones[idx].bg === 'sf' ? bg_sf : bg_hk;
        }

        function currentSoulmateVisible() {
            if (gamePhase === GamePhase.Choice || gamePhase === GamePhase.AfterChoiceNo) return false;
            if (gamePhase === GamePhase.AfterChoiceYes) return true;
            return storyMilestones[getCurrentMilestone()].soulmateVisible;
        }

        function currentSoulmateMaskedVisible() {
            return storyMilestones[getCurrentMilestone()].maskedVisible || false;
        }

        function currentStoryText() {
            if (gamePhase === GamePhase.AfterChoiceYes) {
                return afterChoiceYesFrames[afterChoiceYesIndex].text;
            }
            return storyMilestones[getCurrentMilestone()].text;
        }

        // Animation update with frame array tracking and reset on change
        let currentFrames = boyIdleImgs; // default animation frames

        function updateAnimation() {
            animationTimer++;
            const animationRate = movingLeft || movingRight ? 6 : 12;
            if (animationTimer >= animationRate) {
                animationTimer = 0;

                let newFrames;
                if (gamePhase === GamePhase.AfterChoiceYes) {
                    newFrames = boyWalkImgs;
                } else if (movingLeft || movingRight) {
                    if (currentSoulmateMaskedVisible()) {
                        newFrames = boyMaskedWalkImgs;
                    } else if (!currentSoulmateVisible()) {
                        newFrames = boyCryingWalkImgs;
                    } else {
                        newFrames = boyWalkImgs;
                    }
                } else {
                    if (currentSoulmateMaskedVisible()) {
                        newFrames = boyMaskedImgs;
                    } else if (!currentSoulmateVisible()) {
                        newFrames = boyCryingImgs;
                    } else {
                        newFrames = boyIdleImgs;
                    }
                }

                if (newFrames !== currentFrames) {
                    animationFrame = 0;
                    currentFrames = newFrames;
                } else {
                    animationFrame++;
                    if (animationFrame >= currentFrames.length) {
                        animationFrame = 0;
                    }
                }
            }
        }

        function drawCharacter(imgArray, x, y, frame) {
            if (!imgArray.length) return;
            const validFrame = frame % imgArray.length;
            const img = imgArray[validFrame];
            if (img && img.complete) ctx.drawImage(img, x, y, scaledWidth, scaledHeight);
        }

        // Scroll limit calculation for story milestones
        function getMaxScroll() {
            const bgImg = currentBgImage();
            if (!bgImg || !bgImg.width) return -6000;
            const totalWidthNeeded = 5400 + canvas.width;
            const neededRepeats = Math.ceil(totalWidthNeeded / bgImg.width);
            return -(bgImg.width * neededRepeats - canvas.width);
        }

        function wrapText(ctx, text, x, y, maxWidth, lineHeight) {
            const words = text.split(' ');
            let line = '';
            let lines = [];
            for (let n = 0; n < words.length; n++) {
                const testLine = line + words[n] + ' ';
                const metrics = ctx.measureText(testLine);
                const testWidth = metrics.width;
                if (testWidth > maxWidth && n > 0) {
                    lines.push(line);
                    line = words[n] + ' ';
                } else {
                    line = testLine;
                }
            }
            lines.push(line);

            for (let i = 0; i < lines.length; i++) {
                ctx.fillText(lines[i], x, y + i * lineHeight);
            }
        }


        // Draw button helper
        function drawButton(x, y, w, h, fill, textColor, text) {
            ctx.fillStyle = fill;
            ctx.fillRect(x, y, w, h);
            ctx.fillStyle = textColor;
            ctx.font = '28px monospace';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, x + w / 2, y + h / 2);
        }

        function gameLoop() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Handle walking state
            const isWalking = movingLeft || movingRight;

            if (gamePhase === GamePhase.Story) {
                if (movingLeft) worldOffsetX = Math.min(worldOffsetX + scrollSpeed, 0);
                if (movingRight) worldOffsetX = Math.max(worldOffsetX - scrollSpeed, getMaxScroll());
            }

            if (gamePhase === GamePhase.AfterChoiceYes) {
                // Scroll after choice YES frames
                const afterChoiceFrameWidth = canvas.width;
                const afterChoiceTotalWidth = afterChoiceYesFrames.length * afterChoiceFrameWidth;

                if (movingLeft) afterChoiceWorldOffsetX = Math.min(afterChoiceWorldOffsetX + scrollSpeed, 0);
                if (movingRight) afterChoiceWorldOffsetX = Math.max(afterChoiceWorldOffsetX - scrollSpeed, -(afterChoiceTotalWidth - canvas.width));

                // Draw backgrounds tiled horizontally
                for (let i = 0; i < afterChoiceYesFrames.length; i++) {
                    const bgImg = afterChoiceYesBgImgs[i];
                    const x = i * afterChoiceFrameWidth + afterChoiceWorldOffsetX;
                    if (bgImg.complete) {
                        ctx.fillStyle = afterChoiceYesFrames[i].backgroundColor;
                        ctx.fillRect(x, 0, afterChoiceFrameWidth, canvas.height);
                        ctx.drawImage(bgImg, x, 0, afterChoiceFrameWidth, canvas.height);
                    }
                }

                // Display current afterChoiceYes text based on scroll position
                const currentIndex = Math.floor(-afterChoiceWorldOffsetX / afterChoiceFrameWidth);
                const clampedIndex = Math.min(Math.max(currentIndex, 0), afterChoiceYesFrames.length - 1);
                ctx.fillStyle = '#ffffff';
                ctx.font = '20px monospace';
                ctx.textAlign = 'center';
                ctx.fillText(afterChoiceYesFrames[clampedIndex].text, canvas.width / 2, 70);

                // Draw boy and soulmate walking animation
                drawCharacter(boyWalkImgs, boyScreenX, charScreenY, animationFrame);
                drawCharacter(soulmateWalkImgs, soulmateScreenX, charScreenY, animationFrame);

            } else {
                // Draw story background repeatedly
                const bgImg = currentBgImage();
                if (bgImg.complete) {
                    const totalWidthNeeded = 5400 + canvas.width;
                    const repeatCount = Math.ceil(totalWidthNeeded / bgImg.width) + 1;
                    for (let i = 0; i < repeatCount; i++) {
                        const x = i * bgImg.width + worldOffsetX;
                        ctx.drawImage(bgImg, x, 0, bgImg.width, canvas.height);
                    }
                } else {
                    ctx.fillStyle = '#111';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                }

                updateAnimation();

                ctx.fillStyle = '#ffffff';  // white color
                ctx.font = '20px monospace';  // smaller font size
                ctx.shadowBlur = 10;
                ctx.fillText(currentStoryText(), 20, 70);
                ctx.shadowBlur = 0;

                const masked = currentSoulmateMaskedVisible();
                const soulmateVisible = currentSoulmateVisible();

                if (gamePhase === GamePhase.Choice) {
                    if (choiceBg.complete) {
                        ctx.drawImage(choiceBg, 0, 0, canvas.width, canvas.height);
                    } else {
                        ctx.fillStyle = '#111';
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                    }

                    ctx.font = '20px monospace';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'top';
                    ctx.fillStyle = '#ffffff';

                    // Display visible text either as partial or full during pause
                    const fullyTyped = charIndex >= choiceSentences[choiceSentenceIndex].length;
                    const visibleText = fullyTyped ? choiceSentences[choiceSentenceIndex] : choiceSentences[choiceSentenceIndex].substring(0, charIndex);

                    const maxTextWidth = canvas.width * 0.9;
                    const lineHeight = 26;
                    const startY = 10;

                    wrapText(ctx, visibleText, canvas.width / 2, startY, maxTextWidth, lineHeight);

                    if (!fullyTyped) {
                        // Typing characters
                        if (charTimer >= charDelay) {
                            charIndex++;
                            charTimer = 0;
                        } else {
                            charTimer++;
                        }
                    } else {
                        // Pause timer after sentence fully typed
                        if (pauseTimer > 0) {
                            pauseTimer--;
                        } else {
                            // Once pause done, move to next sentence and reset
                            choiceSentenceIndex = (choiceSentenceIndex + 1) % choiceSentences.length;
                            charIndex = 0;
                            pauseTimer = sentencePause; // Reset pause for next full sentence
                        }
                    }

                    drawButton(canvas.width / 2 - 140, canvas.height - 100, 120, 60, '#39ff14', '#000', 'YES');
                    drawButton(canvas.width / 2 + 20, canvas.height - 100, 120, 60, '#f33914', '#000', 'NO');
                }
                else if (gamePhase === GamePhase.AfterChoiceNo) {
                    ctx.fillStyle = 'rgba(0,0,0,0.6)';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = '#ffffff';
                    ctx.font = '20px monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText('You chose NO. Soulmate left.', canvas.width / 2, canvas.height / 2);
                    if (isWalking) {
                        drawCharacter(boyCryingWalkImgs, boyScreenX, charScreenY, animationFrame);
                    } else {
                        drawCharacter(boyCryingImgs, boyScreenX, charScreenY, animationFrame);
                    }
                } else if (gamePhase === GamePhase.End) {
                    ctx.fillStyle = '#ffffff';
                    ctx.font = '20px monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText('The End', canvas.width / 2, canvas.height / 2);
                } else {
                    // Normal story animation drawing
                    if (soulmateVisible) {
                        if (masked) {
                            if (isWalking) {
                                drawCharacter(boyMaskedWalkImgs, boyScreenX, charScreenY, animationFrame);
                                drawCharacter(soulmateMaskedWalkImgs, soulmateScreenX, charScreenY, animationFrame);
                            } else {
                                drawCharacter(boyMaskedImgs, boyScreenX, charScreenY, animationFrame);
                                drawCharacter(soulmateMaskedImgs, soulmateScreenX, charScreenY, animationFrame);
                            }
                        } else {
                            if (isWalking) {
                                drawCharacter(boyWalkImgs, boyScreenX, charScreenY, animationFrame);
                                drawCharacter(soulmateWalkImgs, soulmateScreenX, charScreenY, animationFrame);
                            } else {
                                drawCharacter(boyIdleImgs, boyScreenX, charScreenY, animationFrame);
                                drawCharacter(soulmateIdleImgs, soulmateScreenX, charScreenY, animationFrame);
                            }
                        }
                    } else {
                        // Crying boy animations when soulmate invisible
                        if (isWalking) {
                            drawCharacter(boyCryingWalkImgs, boyScreenX, charScreenY, animationFrame);
                        } else {
                            drawCharacter(boyCryingImgs, boyScreenX, charScreenY, animationFrame);
                        }
                    }
                }
            }

            // Automatically switch to Choice phase at last milestone
            if (getCurrentMilestone() === storyMilestones.length - 1 && gamePhase === GamePhase.Story) {
                gamePhase = GamePhase.Choice;
            }

            requestAnimationFrame(gameLoop);
        }

        // Input handlers for story and after choice YES scroll
        window.addEventListener('keydown', e => {
            const isMovementKey = e.key === 'ArrowLeft' || e.key.toLowerCase() === 'a' || e.key === 'ArrowRight' || e.key.toLowerCase() === 'd';
            if (!isMovementKey) return;

            if (gamePhase === GamePhase.Story) {
                if (e.key === 'ArrowLeft' || e.key.toLowerCase() === 'a') movingLeft = true;
                if (e.key === 'ArrowRight' || e.key.toLowerCase() === 'd') movingRight = true;
            } else if (gamePhase === GamePhase.AfterChoiceYes) {
                if (e.key === 'ArrowLeft' || e.key.toLowerCase() === 'a') movingLeft = true;
                if (e.key === 'ArrowRight' || e.key.toLowerCase() === 'd') movingRight = true;
            }
        });

        window.addEventListener('keyup', e => {
            const isMovementKey = e.key === 'ArrowLeft' || e.key.toLowerCase() === 'a' || e.key === 'ArrowRight' || e.key.toLowerCase() === 'd';
            if (!isMovementKey) return;

            if (gamePhase === GamePhase.Story) {
                if (e.key === 'ArrowLeft' || e.key.toLowerCase() === 'a') movingLeft = false;
                if (e.key === 'ArrowRight' || e.key.toLowerCase() === 'd') movingRight = false;
            } else if (gamePhase === GamePhase.AfterChoiceYes) {
                if (e.key === 'ArrowLeft' || e.key.toLowerCase() === 'a') movingLeft = false;
                if (e.key === 'ArrowRight' || e.key.toLowerCase() === 'd') movingRight = false;
            }
        });

        // Touch input handlers (optional) - simplified for brevity
        let touchStartX = null;
        canvas.addEventListener('touchstart', e => {
            if (gamePhase === GamePhase.Story || gamePhase === GamePhase.AfterChoiceYes) {
                touchStartX = e.touches[0].clientX;
            }
        });

        canvas.addEventListener('touchmove', e => {
            if (touchStartX === null) return;
            const currentX = e.touches[0].clientX;
            const diff = currentX - touchStartX;
            if (diff > 10) {
                movingLeft = true;
                movingRight = false;
            } else if (diff < -10) {
                movingRight = true;
                movingLeft = false;
            }
        });

        canvas.addEventListener('touchend', e => {
            movingLeft = false;
            movingRight = false;
            touchStartX = null;
        });

        canvas.addEventListener('click', e => {
            const rect = canvas.getBoundingClientRect();
            const clickX = e.clientX - rect.left;
            const clickY = e.clientY - rect.top;

            if (gamePhase === GamePhase.Choice) {
                // YES button box
                if (clickX >= canvas.width / 2 - 140 &&
                    clickX <= canvas.width / 2 - 20 &&
                    clickY >= canvas.height - 100 &&
                    clickY <= canvas.height - 40) {
                    playerChoice = 'yes';
                    gamePhase = GamePhase.AfterChoiceYes;
                    afterChoiceWorldOffsetX = 0;
                    movingLeft = false;
                    movingRight = false;
                    console.log('User choice tracked: yes');
                }
                // NO button box
                else if (clickX >= canvas.width / 2 + 20 &&
                    clickX <= canvas.width / 2 + 140 &&
                    clickY >= canvas.height - 100 &&
                    clickY <= canvas.height - 40) {
                    playerChoice = 'no';
                    gamePhase = GamePhase.AfterChoiceNo;
                    console.log('User choice tracked: no');
                }
            }
        });



        requestAnimationFrame(gameLoop);
    </script>

</body>

</html>
