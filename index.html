<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>awSince2011</title>
  <style>
    body { margin: 0; overflow: hidden; background: #111; }
    canvas { display: block; margin: auto; background: #111; touch-action: none; }
  </style>
</head>
<body>

<canvas id="gameCanvas" width="800" height="400"></canvas>

<!-- GameAnalytics SDK -->
<script>
  (function(w,d,s,u){
    w['GameAnalytics'] = w['GameAnalytics'] || function(){(w['GameAnalytics'].q = w['GameAnalytics'].q || []).push(arguments)};
    var ga = d.createElement(s), m = d.getElementsByTagName(s)[0];
    ga.async = 1;
    ga.src = u;
    m.parentNode.insertBefore(ga,m);
  })(window,document,'script','https://download.gameanalytics.com/js/GameAnalytics.latest.min.js');

  GameAnalytics("setEnabledInfoLog", true);
  GameAnalytics("initialize", "74d3259c304d64ec6ad15574eb975019", "d9212b3ec2f73ae0648888f637774c1b8b455bcf");
</script>

<script>
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');

  // Frames
  const boyIdleFrames = ['pixel_boy_idle_1.png', 'pixel_boy_idle_2.png', 'pixel_boy_idle_3.png'];
  const boyCryingFrames = ['pixel_boy_crying_1.png', 'pixel_boy_crying_2.png', 'pixel_boy_crying_3.png'];
  const soulmateIdleFrames = ['pixel_soulmate_idle_1.png', 'pixel_soulmate_idle_2.png', 'pixel_soulmate_idle_3.png'];

  function preloadFrames(urls) {
    return urls.map(url => {
      const img = new Image();
      img.src = url;
      return img;
    });
  }

  const boyIdleImgs = preloadFrames(boyIdleFrames);
  const boyCryingImgs = preloadFrames(boyCryingFrames);
  const soulmateIdleImgs = preloadFrames(soulmateIdleFrames);

  const frameWidth = 40;
  const frameHeight = 60;
  const scale = 4;
  const scaledWidth = frameWidth * scale;
  const scaledHeight = frameHeight * scale;

  const canvasWidth = canvas.width;
  const canvasHeight = canvas.height;

  // Background images for 2011 and other years
  const bg_sf = new Image();
  bg_sf.src = 'pixel_sf.png';
  const bg_hk = new Image();
  bg_hk.src = 'pixel_hk.png';

  let worldOffsetX = 0;
  const scrollSpeed = 5;

  const boyScreenX = 200;
  const soulmateScreenX = boyScreenX + scaledWidth + 20;
  const charScreenY = 120;

  let animationFrame = 0;
  let animationTimer = 0;
  const animationSpeed = 12;

  let movingLeft = false;
  let movingRight = false;

  // Story and soulmate visibility timeline — pixel-based scroll positions:
  // Includes which background to use per state, soulmate visible or not
  const storyMilestones = [
    { x: 0, text: "The boy starts the year filled with hope.", soulmateVisible: true, bg: 'sf' },
    { x: 150, text: "In August 2011 they start dating officially.", soulmateVisible: true, bg: 'sf' },
    { x: 300, text: "Separated August to December 2011.", soulmateVisible: false, bg: 'sf' },
    { x: 450, text: "Reunited after December 2011.", soulmateVisible: true, bg: 'hk' },
    { x: 600, text: "Friends grow closer, hearts grow fonder.", soulmateVisible: true, bg: 'hk' },
    { x: 900, text: "Love deepens over time.", soulmateVisible: true, bg: 'hk' },
    { x: 1200, text: "Preparing for a joyful future.", soulmateVisible: true, bg: 'hk' },
    { x: 1500, text: "Wedding day surrounded by love.", soulmateVisible: true, bg: 'hk' },
    { x: 1800, text: "Life brings many adventures.", soulmateVisible: true, bg: 'hk' },
    { x: 2100, text: "Cherished moments together.", soulmateVisible: true, bg: 'hk' },
    { x: 2400, text: "Overcoming challenges with strength.", soulmateVisible: true, bg: 'hk' },
    { x: 2700, text: "Tough times in September 2019.", soulmateVisible: false, bg: 'hk' },
    { x: 3000, text: "Reunited after November 2019.", soulmateVisible: true, bg: 'hk' },
    { x: 3300, text: "A world changed, faces masked.", soulmateVisible: true, bg: 'hk' },
    { x: 3600, text: "Hope grows anew.", soulmateVisible: true, bg: 'hk' },
    { x: 3900, text: "New beginnings in a new home.", soulmateVisible: true, bg: 'hk' },
    { x: 4200, text: "Dreams and doubts meet.", soulmateVisible: true, bg: 'hk' },
    { x: 4500, text: "Uncertainty looms.", soulmateVisible: true, bg: 'hk' },
    { x: 4800, text: "August 2025 - Marriage at crossroads.", soulmateVisible: false, bg: 'hk' },
    { x: 5100, text: "Reunited after August 2025.", soulmateVisible: true, bg: 'hk' },
    { x: 5400, text: "Ending story.", soulmateVisible: true, bg: 'hk' },
  ];

  const GamePhase = {
    Story: 0,
    Choice: 1,
    AfterChoiceYes: 2,
    AfterChoiceNo: 3,
    End: 4,
  };

  let gamePhase = GamePhase.Story;
  let playerChoice = null;

  function getCurrentMilestone() {
    for (let i = storyMilestones.length - 1; i >= 0; i--) {
      if (worldOffsetX >= storyMilestones[i].x) return i;
    }
    return 0;
  }

  function currentSoulmateVisible() {
    if (gamePhase === GamePhase.Choice || gamePhase === GamePhase.AfterChoiceNo) return false;
    if (gamePhase === GamePhase.AfterChoiceYes) return true;
    const index = getCurrentMilestone();
    return storyMilestones[index].soulmateVisible;
  }

  function currentBgImage(){
    const index = getCurrentMilestone();
    const bgType = storyMilestones[index].bg;
    if(bgType === 'sf') return bg_sf;
    return bg_hk;
  }

  function currentStoryText() {
    const index = getCurrentMilestone();
    return storyMilestones[index].text;
  }

  function updateAnimation() {
    animationTimer++;
    if (animationTimer >= animationSpeed) {
      animationTimer = 0;
      animationFrame = (animationFrame + 1) % boyIdleImgs.length;
    }
  }

  function drawCharacter(imgArray, x, y, frame) {
    if (!imgArray.length) return;
    const img = imgArray[frame];
    if (img.complete) {
      ctx.drawImage(img, x, y, scaledWidth, scaledHeight);
    }
  }

  function gameLoop() {
    ctx.clearRect(0, 0, canvasWidth, canvasHeight);

    if (gamePhase === GamePhase.Story) {
      if (movingLeft) {
        worldOffsetX = Math.min(worldOffsetX + scrollSpeed, 0);
      }
      if (movingRight) {
        const maxRight = - (currentBgImage().width * 3 - canvasWidth);
        worldOffsetX = Math.max(worldOffsetX - scrollSpeed, maxRight);
      }
    }

    // Draw background – tiling current background horizontally
    const bgImg = currentBgImage();
    if (bgImg.complete) {
      for(let i = -Math.floor((-worldOffsetX)/bgImg.width)-1; i <= Math.ceil(canvasWidth/bgImg.width); i++) {
        ctx.drawImage(bgImg, i*bgImg.width + worldOffsetX, 0, bgImg.width, canvasHeight);
      }
    } else {
      ctx.fillStyle = '#111';
      ctx.fillRect(0, 0, canvasWidth, canvasHeight);
    }

    updateAnimation();

    // Draw story text
    ctx.fillStyle = '#39ff14';
    ctx.font = '28px monospace';
    ctx.shadowColor = '#39ff14';
    ctx.shadowBlur = 10;
    ctx.fillText(currentStoryText(), 20, 70);
    ctx.shadowBlur = 0;

    // Draw boy and soulmate or crying boy depending on soulmate visibility
    if (currentSoulmateVisible()) {
      drawCharacter(boyIdleImgs, boyScreenX, charScreenY, animationFrame);
      drawCharacter(soulmateIdleImgs, soulmateScreenX, charScreenY, animationFrame);
    } else {
      drawCharacter(boyCryingImgs, boyScreenX, charScreenY, animationFrame);
    }

    if (getCurrentMilestone() === storyMilestones.length - 1 && gamePhase === GamePhase.Story) {
      gamePhase = GamePhase.Choice;
    }

    if (gamePhase === GamePhase.Choice) {
      ctx.fillStyle = 'rgba(0,0,0,0.7)';
      ctx.fillRect(0, 0, canvasWidth, canvasHeight);
      ctx.fillStyle = '#39ff14';
      ctx.font = '36px monospace';
      ctx.textAlign = 'center';
      ctx.fillText("Should the soulmate return?", canvasWidth / 2, canvasHeight / 2 - 40);

      drawButton(canvasWidth / 2 - 140, canvasHeight / 2, 120, 60, '#39ff14', '#000', 'YES');
      drawButton(canvasWidth / 2 + 20, canvasHeight / 2, 120, 60, '#f33914', '#000', 'NO');
    }

    if (gamePhase === GamePhase.AfterChoiceYes) {
      ctx.fillStyle = 'rgba(0,0,0,0.6)';
      ctx.fillRect(0, 0, canvasWidth, canvasHeight);
      ctx.fillStyle = '#39ff14';
      ctx.font = '36px monospace';
      ctx.textAlign = 'center';
      ctx.fillText("You chose YES. Soulmate is back.", canvasWidth / 2, canvasHeight / 2);

      // Draw boy and soulmate both visible
      drawCharacter(boyIdleImgs, boyScreenX, charScreenY, animationFrame);
      drawCharacter(soulmateIdleImgs, soulmateScreenX, charScreenY, animationFrame);
    }

    if (gamePhase === GamePhase.AfterChoiceNo) {
      ctx.fillStyle = 'rgba(0,0,0,0.6)';
      ctx.fillRect(0, 0, canvasWidth, canvasHeight);
      ctx.fillStyle = '#39ff14';
      ctx.font = '36px monospace';
      ctx.textAlign = 'center';
      ctx.fillText("You chose NO. Soulmate left.", canvasWidth / 2, canvasHeight / 2);
      drawCharacter(boyCryingImgs, boyScreenX, charScreenY, animationFrame);
    }

    requestAnimationFrame(gameLoop);
  }

  // Draw button helper
  function drawButton(x, y, w, h, fill, textColor, text) {
    ctx.fillStyle = fill;
    ctx.fillRect(x, y, w, h);
    ctx.fillStyle = textColor;
    ctx.font = '28px monospace';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(text, x + w / 2, y + h / 2);
  }

  // Keyboard movement
  window.addEventListener('keydown', e => {
    if (gamePhase === GamePhase.Story) {
      if (e.key === 'ArrowLeft' || e.key.toLowerCase() === 'a') movingLeft = true;
      if (e.key === 'ArrowRight' || e.key.toLowerCase() === 'd') movingRight = true;
    }
  });
  window.addEventListener('keyup', e => {
    if (gamePhase === GamePhase.Story) {
      if (e.key === 'ArrowLeft' || e.key.toLowerCase() === 'a') movingLeft = false;
      if (e.key === 'ArrowRight' || e.key.toLowerCase() === 'd') movingRight = false;
    }
  });

  // Mobile touch controls for left/right movement
  let touchStartX = null;
  canvas.addEventListener('touchstart', e => {
    if (gamePhase === GamePhase.Story) {
      touchStartX = e.touches[0].clientX;
    }
  });

  canvas.addEventListener('touchmove', e => {
    if (touchStartX === null) return;
    const currentX = e.touches[0].clientX;
    const diff = currentX - touchStartX;

    if (diff > 10) {
      movingLeft = true;
      movingRight = false;
    } else if (diff < -10) {
      movingRight = true;
      movingLeft = false;
    }
  });

  canvas.addEventListener('touchend', e => {
    movingLeft = false;
    movingRight = false;
    touchStartX = null;
  });

  // Click/tap choice buttons
  canvas.addEventListener('click', e => {
    if (gamePhase !== GamePhase.Choice) return;
    const rect = canvas.getBoundingClientRect();
    const clickX = e.clientX - rect.left;
    const clickY = e.clientY - rect.top;

    if (clickX >= canvasWidth / 2 - 140 && clickX <= canvasWidth / 2 - 20 &&
        clickY >= canvasHeight / 2 && clickY <= canvasHeight / 2 + 60) {
      playerChoice = 'yes';
      GameAnalytics("addDesignEvent", `player_choice:yes`);
      gamePhase = GamePhase.AfterChoiceYes;
    } else if (clickX >= canvasWidth / 2 + 20 && clickX <= canvasWidth / 2 + 140 &&
               clickY >= canvasHeight / 2 && clickY <= canvasHeight / 2 + 60) {
      playerChoice = 'no';
      GameAnalytics("addDesignEvent", `player_choice:no`);
      gamePhase = GamePhase.AfterChoiceNo;
    }
  });

  let movingLeft = false;
  let movingRight = false;
  gameLoop();
</script>

</body>
</html>
